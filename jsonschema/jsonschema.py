"""JSON Schema output plugin
"""

# pylint: disable=C0111

from __future__ import print_function

import optparse
import logging

import json

from pyang import plugin
from pyang import statements
from pyang import types
from pyang import error

def pyang_plugin_init():
    plugin.register_plugin(JSONSchemaPlugin())

class JSONSchemaPlugin(plugin.PyangPlugin):
    def add_output_format(self, fmts):
        fmts['jsonschema'] = self

    def add_opts(self, optparser):
        optlist = [
            optparse.make_option('--jsonschema-debug',
                                 dest='schema_debug',
                                 action="store_true",
                                 help='JSON Schema debug'),
            optparse.make_option('--jsonschema-path',
                                 dest='schema_path',
                                 help='JSON Schema path'),
            optparse.make_option('--jsonschema-title',
                                 dest='schema_title',
                                 help='JSON Schema title'),
            ]

        group = optparser.add_option_group("JSON Schema-specific options")
        group.add_options(optlist)

    def setup_ctx(self, ctx):
        ctx.opts.stmts = None

    def setup_fmt(self, ctx):
        ctx.implicit_errors = False

    def emit(self, ctx, modules, fd):
        root_stmt = modules[0]
        if ctx.opts.schema_debug:
            logging.basicConfig(level=logging.DEBUG)
            print("")
        if ctx.opts.schema_path is not None:
            logging.debug("schema_path: %s", ctx.opts.schema_path)
            path = ctx.opts.schema_path
            root_stmt = find_stmt_by_path(modules[0], path)
        else:
            path = None

        if ctx.opts.schema_title is not None:
            schema_title = ctx.opts.schema_title
        else:
            schema_title = root_stmt.arg

        description_str = "Generated by pyang from module %s" % modules[0].arg
        result = {"title": schema_title,
                  "$schema": "http://json-schema.org/draft-04/schema#",
                  "description": description_str,
                  "type": "object",
                  "properties": {}}

        schema = produce_schema(root_stmt)
        result["properties"].update(schema)

        fd.write(json.dumps(result, indent=2))

def find_stmt_by_path(module, path):
    logging.debug("in find_stmt_by_path with: %s %s path: %s", module.keyword, module.arg, path)

    if path is not None:
        spath = path.split("/")
        if spath[0] == '':
            spath = spath[1:]

    children = [child for child in module.i_children
                if child.keyword in statements.data_definition_keywords]

    while spath is not None and len(spath) > 0:
        match = [child for child in children if child.arg == spath[0]
                 and child.keyword in statements.data_definition_keywords]
        if len(match) > 0:
            logging.debug("Match on: %s, path: %s", match[0].arg, spath)
            spath = spath[1:]
            children = match[0].i_children
            logging.debug("Path is now: %s", spath)
        else:
            logging.debug("Miss at %s, path: %s", children, spath)
            raise error.EmitError("Path '%s' does not exist in module" % path)

    logging.debug("Ended up with %s %s", match[0].keyword, match[0].arg)
    return match[0]


def produce_schema(root_stmt):
    logging.debug("in produce_schema: %s %s", root_stmt.keyword, root_stmt.arg)
    result = {}

    for child in root_stmt.i_children:
        if child.keyword in statements.data_definition_keywords:
            if child.keyword in producers:
                logging.debug("keyword hit on: %s %s", child.keyword, child.arg)
                add = producers[child.keyword](child)
                result.update(add)
            else:
                logging.debug("keyword miss on: %s %s", child.keyword, child.arg)
        else:
            logging.debug("keyword not in data_definition_keywords: %s %s", child.keyword,
                          child.arg)
    return result

def produce_type(type_stmt):
    logging.debug("In produce_type with: %s %s", type_stmt.keyword, type_stmt.arg)
    type_id = type_stmt.arg

    if types.is_base_type(type_id):
        if type_id in _numeric_type_trans_tbl:
            type_str = numeric_type_trans(type_id)
        elif type_id in _other_type_trans_tbl:
            type_str = other_type_trans(type_id, type_stmt)
        else:
            logging.debug("Missing mapping of base type: %s %s",
                          type_stmt.keyword, type_stmt.arg)
            type_str = {"type": "string"}
    elif hasattr(type_stmt, "i_typedef") and type_stmt.i_typedef is not None:
        logging.debug("Found typedef type in: %s %s (typedef) %s",
                      type_stmt.keyword, type_stmt.arg, type_stmt.i_typedef)
        typedef_type_stmt = type_stmt.i_typedef.search_one('type')
        typedef_type = produce_type(typedef_type_stmt)
        type_str = typedef_type
    else:
        logging.debug("Missing mapping of: %s %s",
                      type_stmt.keyword, type_stmt.arg, type_stmt.i_typedef)
        type_str = {}

    set_constraint(type_str, "pattern", get_constraint(type_stmt, "pattern"))
    if get_constraint(type_stmt, "range") is not None or get_constraint(type_stmt, "length") is not None:
        constraint = get_constraint(type_stmt, "range")
        t = "range"
        if constraint is None:
            constraint = get_constraint(type_stmt, "length")
            t = "length"
        ranges = []
        for c in constraint.split("|"):
            if ".." in c:
                start = gen_num(c.split("..")[0])
                end = gen_num(c.split("..")[1])
            else:
                start = gen_num(c)
                end = gen_num(c)

            if ranges and start == ranges[-1][1] + 1:
                ranges[-1][1] = end
            else:
                ranges.append([start, end])

        if len(ranges) > 1:
            # Generate a "anyOf" constraint
            sub_type = type_str
            type_str = {"anyOf": []}
            for r in ranges:
                # Normal range
                new = dict(sub_type)
                if sub_type["type"] in ["integer", "number"]:
                    set_constraint(new, "minimum", ranges[0][0])
                    set_constraint(new, "maximum", ranges[0][1])
                elif sub_type["type"] == "string":
                    set_constraint(new, "minLength", ranges[0][0])
                    set_constraint(new, "maxLength", ranges[0][1])
                else:
                    logging.error("Range/length specified for unknown type at definition '%s'" % str(type_stmt))
                for v in type_str["anyOf"]:
                    if v == new:
                        break
                else:
                    type_str["anyOf"].append(new)
            if len(type_str["anyOf"]) == 1:
                type_str = type_str["anyOf"][0]
        else:
            # Normal range
            if type_str["type"] in ["integer", "number"]:
                set_constraint(type_str, "minimum", ranges[0][0])
                set_constraint(type_str, "maximum", ranges[0][1])
            elif type_str["type"] == "string":
                set_constraint(type_str, "minLength", ranges[0][0])
                set_constraint(type_str, "maxLength", ranges[0][1])
            else:
                logging.error("Range/length specified for unknown type at definition '%s'" % str(type_stmt))

    set_constraint(type_str, "description", get_constraint(type_stmt, "description"))

    return type_str

def produce_leaf(stmt):
    logging.debug("in produce_leaf: %s %s", stmt.keyword, stmt.arg)
    arg = qualify_name(stmt)

    type_stmt = stmt.search_one('type')
    type_str = produce_type(type_stmt)

    set_constraint(type_str, "description", get_constraint(stmt, "description"))

    return {arg: type_str}

def produce_list(stmt):
    logging.debug("in produce_list: %s %s", stmt.keyword, stmt.arg)
    arg = qualify_name(stmt)

    result = {arg: {"type": "array", "items": {}}}
    set_constraint(result[arg], "maxItems", get_constraint(stmt, "max-elements"))
    set_constraint(result[arg], "minItems", get_constraint(stmt, "min-elements"))
    set_constraint(result[arg], "description", get_constraint(stmt, "description"))

    if hasattr(stmt, 'i_children'):
        for child in stmt.i_children:
            if child.keyword in producers:
                logging.debug("keyword hit on: %s %s", child.keyword, child.arg)
                result[arg]["items"]["type"] = "object"
                result[arg]["items"].setdefault("properties", {}).update(producers[child.keyword](child))
                if child.search_one("mandatory") and child.search_one("mandatory").arg == "true":
                    key = list(producers[child.keyword](child))[0]
                    result[arg]["items"].setdefault("required", []).append(key)
            else:
                logging.debug("keyword miss on: %s %s", child.keyword, child.arg)
    logging.debug("In produce_list for %s, returning %s", stmt.arg, result)

    set_constraint(result[arg], "description", get_constraint(stmt, "description"))

    return result

def produce_leaf_list(stmt):
    logging.debug("in produce_leaf_list: %s %s", stmt.keyword, stmt.arg)
    arg = qualify_name(stmt)
    type_stmt = stmt.search_one('type')
    type_id = type_stmt.arg

    result = {arg: {"type": "array", "items": produce_type(type_stmt)}}
    set_constraint(result[arg], "maxItems", get_constraint(stmt, "max-elements"))
    set_constraint(result[arg], "minItems", get_constraint(stmt, "min-elements"))
    set_constraint(result[arg], "description", get_constraint(stmt, "description"))
    return result

def produce_container(stmt):
    logging.debug("in produce_container: %s %s", stmt.keyword, stmt.arg)
    arg = qualify_name(stmt)

    result = {arg: {"type": "object", "properties": {}}}

    if hasattr(stmt, 'i_children'):
        for child in stmt.i_children:
            if child.keyword in producers:
                logging.debug("keyword hit on: %s %s", child.keyword, child.arg)
                result[arg]["properties"].update(producers[child.keyword](child))
                # NOTE we should find a way to set "required" for a choice as well
                if child.keyword != "choice" and child.search_one("mandatory") and child.search_one("mandatory").arg == "true":
                    key = list(producers[child.keyword](child))[0]
                    result[arg].setdefault("required", []).append(key)
            else:
                logging.debug("keyword miss on: %s %s", child.keyword, child.arg)
    logging.debug("In produce_container, returning %s", result)
    set_constraint(result[arg], "description", get_constraint(stmt, "description"))
    return result

def produce_choice(stmt):
    logging.debug("in produce_choice: %s %s", stmt.keyword, stmt.arg)

    result = {}

    # https://tools.ietf.org/html/rfc6020#section-7.9.2
    for case in stmt.search("case"):
        if hasattr(case, 'i_children'):
            for child in case.i_children:
                if child.keyword in producers:
                    logging.debug("keyword hit on (long version): %s %s", child.keyword, child.arg)
                    result.update(producers[child.keyword](child))
                else:
                    logging.debug("keyword miss on: %s %s", child.keyword, child.arg)

    # Short ("case-less") version
    #  https://tools.ietf.org/html/rfc6020#section-7.9.2
    for child in stmt.substmts:
        logging.debug("checking on keywords with: %s %s", child.keyword, child.arg)
        if child.keyword in ["container", "leaf", "list", "leaf-list"]:
            logging.debug("keyword hit on (short version): %s %s", child.keyword, child.arg)
            result.update(producers[child.keyword](child))

    logging.debug("In produce_choice, returning %s", result)
    return result

producers = {
    # "module":     produce_module,
    "container":    produce_container,
    "list":         produce_list,
    "leaf-list":    produce_leaf_list,
    "leaf":         produce_leaf,
    "choice":       produce_choice,
}

_numeric_type_trans_tbl = {
    # https://tools.ietf.org/html/draft-ietf-netmod-yang-json-02#section-6
    "int8": ("number", None),
    "int16": ("number", None),
    "int32": ("number", "int32"),
    "int64": ("integer", "int64"),
    "uint8": ("number", None),
    "uint16": ("number", None),
    "uint32": ("integer", "uint32"),
    "uint64": ("integer", "uint64")
    }

def numeric_type_trans(dtype):
    trans_type = _numeric_type_trans_tbl[dtype][0]
    # Should include format string in return value
    # tformat = _numeric_type_trans_tbl[dtype][1]
    result = {"type": trans_type}
    return result

def string_trans(stmt):
    logging.debug("in string_trans with stmt %s %s", stmt.keyword, stmt.arg)
    result = {"type": "string"}
    set_constraint(result, "description", get_constraint(stmt, "description"))
    set_constraint(result, "pattern", get_constraint(stmt, "pattern"))
    return result

def enumeration_trans(stmt):
    logging.debug("in enumeration_trans with stmt %s %s", stmt.keyword, stmt.arg)
    result = {"enum": []}
    for enum in stmt.search("enum"):
        result["enum"].append(enum.arg)
    logging.debug("In enumeration_trans for %s, returning %s", stmt.arg, result)
    set_constraint(result, "description", get_constraint(stmt, "description"))
    return result

def bits_trans(stmt):
    logging.debug("in bits_trans with stmt %s %s", stmt.keyword, stmt.arg)
    result = {"type": "string"}
    set_constraint(result, "description", get_constraint(stmt, "description"))
    set_constraint(result, "pattern", get_constraint(stmt, "pattern"))
    return result

def boolean_trans(stmt):
    logging.debug("in boolean_trans with stmt %s %s", stmt.keyword, stmt.arg)
    result = {"type": "boolean"}
    set_constraint(result, "description", get_constraint(stmt, "description"))
    return result

def empty_trans(stmt):
    logging.debug("in empty_trans with stmt %s %s", stmt.keyword, stmt.arg)
    result = {"type": "array", "maxItems": 0}
    set_constraint(result, "description", get_constraint(stmt, "description"))
    # Likely needs more/other work per:
    #  https://tools.ietf.org/html/draft-ietf-netmod-yang-json-10#section-6.9
    return result

def union_trans(stmt):
    logging.debug("in union_trans with stmt %s %s", stmt.keyword, stmt.arg)
    # NOTE use anyOf instead of oneOf, as sometimes values can overlap (e.g., just string type or with a simple pattern), which then prevents a oneOf from matching
    result = {"anyOf": []}
    for member in stmt.search("type"):
        member_type = produce_type(member)
        for v in result["anyOf"]:
            if v == member_type:
                break
        else:
            result["anyOf"].append(member_type)
    if len(result["anyOf"]) == 1:
        return result["anyOf"][0]
    return result

def instance_identifier_trans(stmt):
    logging.debug("in instance_identifier_trans with stmt %s %s", stmt.keyword, stmt.arg)
    result = {"type": "string"}
    set_constraint(result, "description", get_constraint(stmt, "description"))
    set_constraint(result, "pattern", get_constraint(stmt, "pattern"))
    return result

def leafref_trans(stmt):
    logging.debug("in leafref_trans with stmt %s %s", stmt.keyword, stmt.arg)
    path = stmt.search_one("path").arg
    import re
    path = re.sub("\\[.*?\\]", "", path)
    current = stmt.parent
    for p in path.split("/"):
        if p == "..":
            current = current.parent
            while current.keyword in ["choice", "case"]:
                # Choice node can be skipped
                current = current.parent
        else:
            if "[" in p:
                p = p.split("[")[0]
            if current is None:
                logging.warning("could not resolve path '%s': element '%s' not found; not generating schema for this" % (path, p))
                return {}
            for child in current.substmts:
                if child.keyword in producers and child.arg == p:
                    current = child
                    break
            else:
                logging.warning("could not resolve path '%s': element '%s' not found; not generating schema for this" % (path, p))
                return {}
    produced = list(producers[current.keyword](current).values())[0]
    result = produced
    set_constraint(result, "description", get_constraint(stmt, "description"))
    set_constraint(result, "pattern", get_constraint(stmt, "pattern"))
    return result

_other_type_trans_tbl = {
    # https://tools.ietf.org/html/draft-ietf-netmod-yang-json-02#section-6
    "string":                   string_trans,
    "enumeration":              enumeration_trans,
    "bits":                     bits_trans,
    "boolean":                  boolean_trans,
    "empty":                    empty_trans,
    "union":                    union_trans,
    "instance-identifier":      instance_identifier_trans,
    "leafref":                  leafref_trans
}

def other_type_trans(dtype, stmt):
    return _other_type_trans_tbl[dtype](stmt)

def qualify_name(stmt):
    # From: draft-ietf-netmod-yang-json
    # A namespace-qualified member name MUST be used for all members of a
    # top-level JSON object, and then also whenever the namespaces of the
    # data node and its parent node are different.  In all other cases, the
    # simple form of the member name MUST be used.
    if stmt.parent.parent is None: # We're on top
        pfx = stmt.i_module.arg
        logging.debug("In qualify_name with: %s %s on top", stmt.keyword, stmt.arg)
        return pfx + ":" + stmt.arg
    if stmt.top.arg != stmt.parent.top.arg: # Parent node is different
        pfx = stmt.top.arg
        logging.debug("In qualify_name with: %s %s and parent is different", stmt.keyword, stmt.arg)
        return pfx + ":" + stmt.arg
    return stmt.arg

def get_constraint(stmt, name):
    val = stmt.search_one(name)
    if val is not None:
        return val.arg

def set_constraint(struct, name, value, func=None):
    if value is not None:
        if func is not None:
            value = func(value)

        if name in ["maxItems", "minItems", "minLength", "maxLength", "minimum", "maximum"]:
            # Integer values, so convert
            struct[name] = int(value)
        elif name == "pattern":
            # Do some necessary patching first, to ensure that we have the whole value
            struct[name] = "^(%s)$" % value
        else:
            # String values, so keep as-is
            struct[name] = value

def gen_num(inp):
    if "." in inp:
        return float(inp)
    elif inp == "max":
        return None
    elif inp == "min":
        return None
    else:
        return int(inp)
